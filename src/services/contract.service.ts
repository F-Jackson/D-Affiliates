import { Injectable, Logger } from '@nestjs/common';
import * as crypto from 'crypto';
import PDFDocument from 'pdfkit';
import { UserDocument } from '../schemas/app.schema';

@Injectable()
export class ContractService {
  private readonly logger = new Logger(ContractService.name);

  async generateContractPdf(
    contract: any,
    user: UserDocument,
    version: number,
  ): Promise<{ buffer: Buffer; pdfHash: string }> {
    return new Promise((resolve, reject) => {
      try {
        const pdf = new PDFDocument({
          size: 'A4',
          margin: 50,
          bufferPages: true,
          info: {
            Title: `Affiliate Overview Document - ${contract.contractId} v${version}`,
            Author: 'D-Affiliates Platform',
            Subject: 'Affiliate Financial and Operational Overview',
            Producer: 'D-Affiliates Reporting Engine',
            CreationDate: new Date(),
          },
        });

        const chunks: Buffer[] = [];

        pdf.on('data', (chunk: Buffer) => chunks.push(chunk));

        pdf.on('end', () => {
          const buffer = Buffer.concat(chunks);

          const pdfHash = crypto
            .createHash('sha3-256')
            .update(buffer)
            .digest('hex');

          resolve({ buffer, pdfHash });
        });

        pdf.on('error', reject);

        this.buildHeader(pdf, contract, version);
        this.buildNotice(pdf);
        this.buildOverviewInfo(pdf, contract, version);
        this.buildAffiliateInfo(pdf, user);
        this.buildTransactions(pdf, contract, user);
        this.buildObservations(pdf);
        this.buildIntegritySection(pdf, contract, user);

        pdf.end();
      } catch (err) {
        reject(err);
      }
    });
  }

  /* ---------------- HEADER ---------------- */

  private buildHeader(
    pdf: PDFKit.PDFDocument,
    contract: any,
    version: number,
  ): void {
    pdf
      .fontSize(18)
      .font('Helvetica-Bold')
      .text('AFFILIATE OVERVIEW & FINANCIAL SUMMARY', { align: 'center' });

    pdf.moveDown(0.3);

    pdf
      .fontSize(9)
      .font('Helvetica')
      .text(`Reference ID: ${contract.contractId} | Version: ${version}`, {
        align: 'center',
      });

    pdf
      .fontSize(8)
      .font('Helvetica-Oblique')
      .text(`Generated at: ${new Date().toISOString()} (UTC)`, {
        align: 'center',
      });

    pdf.moveDown(1);
    pdf.moveTo(50, pdf.y).lineTo(545, pdf.y).stroke();
    pdf.moveDown(1);
  }

  /* ---------------- NOTICE ---------------- */

  private buildNotice(pdf: PDFKit.PDFDocument): void {
    pdf.fontSize(10).font('Helvetica-Bold').text('IMPORTANT NOTICE');

    pdf
      .fontSize(8)
      .font('Helvetica')
      .text(
        `This document is a detailed visualization and informational summary generated by the Platform.`,
        { indent: 20 },
      );

    pdf.text(
      `It is intended solely for reference, tracking, and transparency purposes and does not constitute a legal contract, invoice, or enforceable agreement.`,
      { indent: 20 },
    );

    pdf.moveDown(1);
  }

  /* ---------------- OVERVIEW INFO ---------------- */

  private buildOverviewInfo(
    pdf: PDFKit.PDFDocument,
    contract: any,
    version: number,
  ): void {
    pdf.fontSize(11).font('Helvetica-Bold').text('OVERVIEW INFORMATION');

    const items = [
      ['Reference ID', contract.contractId],
      ['Version', version.toString()],
      ['Total Amount', `$${contract.amount.toFixed(2)}`],
      ['Current Status', contract.status.toUpperCase()],
      ['Currency', 'USD'],
      ['Record Type', 'Affiliate Performance Overview'],
    ];

    items.forEach(([label, value]) => {
      pdf.fontSize(9).font('Helvetica-Bold').text(`${label}:`, { indent: 20 });
      pdf.fontSize(9).font('Helvetica').text(value, { indent: 40 });
    });

    pdf.moveDown(1);
  }

  /* ---------------- AFFILIATE INFO ---------------- */

  private buildAffiliateInfo(
    pdf: PDFKit.PDFDocument,
    user: UserDocument,
  ): void {
    pdf.fontSize(11).font('Helvetica-Bold').text('AFFILIATE INFORMATION');

    const items = [
      ['User ID', user.userId],
      ['Affiliate Code', user.affiliateCode],
      ['Account Status', user.status.toUpperCase()],
    ];

    items.forEach(([label, value]) => {
      pdf.fontSize(9).font('Helvetica-Bold').text(`${label}:`, { indent: 20 });
      pdf.fontSize(9).font('Helvetica').text(value, { indent: 40 });
    });

    pdf.moveDown(1);
  }

  /* ---------------- TRANSACTIONS ---------------- */

  private buildTransactions(
    pdf: PDFKit.PDFDocument,
    contract: any,
    user: UserDocument,
  ): void {
    if (!contract.transcationsIds?.length) return;

    pdf
      .fontSize(11)
      .font('Helvetica-Bold')
      .text('RELATED TRANSACTIONS OVERVIEW');

    contract.transcationsIds.slice(0, 10).forEach((txId: string, i: number) => {
      const tx = user.affiliateds
        .flatMap((a) => a.transactions)
        .find((t) => t.id === txId);

      if (tx) {
        pdf
          .fontSize(9)
          .font('Helvetica')
          .text(`${i + 1}. $${tx.amount.toFixed(2)} | ${tx.productName}`, {
            indent: 20,
          });
      }
    });

    pdf.moveDown(1);
  }

  /* ---------------- OBSERVATIONS ---------------- */

  private buildObservations(pdf: PDFKit.PDFDocument): void {
    pdf.fontSize(11).font('Helvetica-Bold').text('GENERAL OBSERVATIONS');

    const text = `
1. INFORMATIONAL PURPOSE.
All data presented reflects the state of the Platform at the time of generation.

2. NO LEGAL EFFECT.
This document does not generate obligations, rights, or guarantees of payment.

3. DATA CONSISTENCY.
Values may change as transactions are processed, reviewed, or adjusted.

4. VERSIONING.
Any update to underlying data will result in a new document version.
`;

    pdf.fontSize(8).font('Helvetica').text(text, {
      indent: 20,
      width: 445,
      align: 'justify',
    });

    pdf.moveDown(1);
  }

  /* ---------------- INTEGRITY ---------------- */

  private buildIntegritySection(
    pdf: PDFKit.PDFDocument,
    contract: any,
    user: UserDocument,
  ): void {
    const integrityPayload = {
      referenceId: contract.contractId,
      userId: user.userId,
      amount: contract.amount,
      status: contract.status,
      generatedAt: new Date().toISOString(),
    };

    const integrityHash = crypto
      .createHash('sha3-256')
      .update(JSON.stringify(integrityPayload))
      .digest('hex');

    pdf.moveTo(50, pdf.y).lineTo(545, pdf.y).stroke();
    pdf.moveDown(0.5);

    pdf
      .fontSize(10)
      .font('Helvetica-Bold')
      .text('DOCUMENT INTEGRITY RECORD', { align: 'center' });

    pdf.moveDown(0.3);

    pdf
      .fontSize(7)
      .font('Helvetica-Oblique')
      .text(`Integrity Hash (SHA3-256):\n${integrityHash}`, {
        align: 'center',
        width: 495,
      });

    pdf.moveDown(0.5);

    pdf
      .fontSize(7)
      .font('Helvetica')
      .text(
        'This hash is provided solely to ensure data integrity and traceability of this visualization.',
        { align: 'center', width: 495 },
      );
  }
}
