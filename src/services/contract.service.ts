import { Injectable, Logger } from '@nestjs/common';
import * as crypto from 'crypto';
import PDFDocument from 'pdfkit';
import { UserDocument } from '../schemas/user.schema';
import { readFileSync } from 'fs';
import { SignPdf } from 'node-signpdf';
import { P12Signer } from '@signpdf/signer-p12';

@Injectable()
export class ContractService {
  async generateContractPdf(
    contract: any,
    user: UserDocument,
    version: number,
  ): Promise<{ buffer: Buffer; pdfHash: string; hmac: string }> {
    return new Promise((resolve, reject) => {
      try {
        const pdf = new PDFDocument({
          size: 'A4',
          margin: 50,
          bufferPages: true,
          userPassword: '',
          ownerPassword: crypto.randomBytes(32).toString('hex'),
          permissions: {
            printing: 'highResolution',
            modifying: false,
            copying: false,
            annotating: false,
            fillingForms: false,
            contentAccessibility: false,
            documentAssembly: false,
          },
          info: {
            Title: `Affiliate Overview - ${contract.contractId} v${version}`,
            Author: 'D-Affiliates Platform',
            Producer: 'D-Affiliates Secure Engine',
            CreationDate: new Date(),
          },
        });

        const chunks: Buffer[] = [];

        pdf.on('data', (chunk: Buffer) => chunks.push(chunk));

        pdf.on('end', () => {
          const unsignedBuffer = Buffer.concat(chunks);

          /* ---------------- HMAC ---------------- */
          const hmac = crypto
            .createHmac('sha256', process.env.PDF_HMAC_SECRET!)
            .update(unsignedBuffer)
            .digest('hex');

          /* ---------------- DIGITAL SIGNATURE ---------------- */
          const p12Buffer = readFileSync(process.env.PDF_CERT_PATH!);

          const signer = new P12Signer(p12Buffer, {
            passphrase: process.env.PDF_CERT_PASSPHRASE!,
          });

          const signPdf = new SignPdf();
          const signedPdf = signPdf.sign(unsignedBuffer, signer);

          const pdfHash = crypto
            .createHash('sha3-256')
            .update(signedPdf)
            .digest('hex');

          resolve({
            buffer: signedPdf,
            pdfHash,
            hmac,
          });
        });

        pdf.on('error', reject);

        this.buildHeader(pdf, contract, version);
        this.buildNotice(pdf);
        this.buildOverviewInfo(pdf, contract, version);
        this.buildAffiliateInfo(pdf, user);
        this.buildTransactions(pdf, contract, user);
        this.buildObservations(pdf);
        this.buildInvisibleWatermark(pdf, contract, user);
        this.buildIntegritySection(pdf, contract, user);

        pdf.end();
      } catch (err) {
        reject(err);
      }
    });
  }

  /* ---------------- HEADER ---------------- */

  private buildHeader(
    pdf: PDFKit.PDFDocument,
    contract: any,
    version: number,
  ): void {
    pdf
      .fontSize(18)
      .font('Helvetica-Bold')
      .text('AFFILIATE OVERVIEW & FINANCIAL SUMMARY', { align: 'center' });

    pdf.moveDown(0.5);

    pdf
      .fontSize(9)
      .font('Helvetica')
      .text(`Reference ID: ${contract.contractId} | Version: ${version}`, {
        align: 'center',
      });

    pdf
      .fontSize(8)
      .font('Helvetica-Oblique')
      .text(`Generated at: ${new Date().toISOString()} (UTC)`, {
        align: 'center',
      });

    pdf.moveDown(1);
    pdf.moveTo(50, pdf.y).lineTo(545, pdf.y).stroke();
    pdf.moveDown(1);
  }

  /* ---------------- NOTICE ---------------- */

  private buildNotice(pdf: PDFKit.PDFDocument): void {
    pdf.fontSize(10).font('Helvetica-Bold').text('IMPORTANT NOTICE');

    pdf
      .fontSize(8)
      .font('Helvetica')
      .text(
        'This document is a visual, informational representation generated by the platform.',
        { indent: 20 },
      );

    pdf.text(
      'It does not constitute a contract, invoice, or legal obligation of any kind.',
      { indent: 20 },
    );

    pdf.moveDown(1);
  }

  /* ---------------- OVERVIEW INFO ---------------- */

  private buildOverviewInfo(
    pdf: PDFKit.PDFDocument,
    contract: any,
    version: number,
  ): void {
    pdf.fontSize(11).font('Helvetica-Bold').text('OVERVIEW INFORMATION');

    const items = [
      ['Reference ID', contract.contractId],
      ['Version', version.toString()],
      ['Total Amount', `$${contract.amount.toFixed(2)}`],
      ['Status', contract.status.toUpperCase()],
      ['Currency', 'USD'],
    ];

    items.forEach(([label, value]) => {
      pdf.fontSize(9).font('Helvetica-Bold').text(`${label}:`, { indent: 20 });
      pdf.fontSize(9).font('Helvetica').text(value, { indent: 40 });
    });

    pdf.moveDown(1);
  }

  /* ---------------- AFFILIATE INFO ---------------- */

  private buildAffiliateInfo(
    pdf: PDFKit.PDFDocument,
    user: UserDocument,
  ): void {
    pdf.fontSize(11).font('Helvetica-Bold').text('AFFILIATE INFORMATION');

    const items = [
      ['User ID', user.userId],
      ['Affiliate Code', user.affiliateCode],
      ['Account Status', user.status.toUpperCase()],
    ];

    items.forEach(([label, value]) => {
      pdf.fontSize(9).font('Helvetica-Bold').text(`${label}:`, { indent: 20 });
      pdf.fontSize(9).font('Helvetica').text(value, { indent: 40 });
    });

    pdf.moveDown(1);
  }

  /* ---------------- TRANSACTIONS ---------------- */

  private buildTransactions(
    pdf: PDFKit.PDFDocument,
    contract: any,
    user: UserDocument,
  ): void {
    if (!contract.transcationsIds?.length) return;

    pdf.fontSize(11).font('Helvetica-Bold').text('RELATED TRANSACTIONS');

    contract.transcationsIds.slice(0, 10).forEach((txId: string, i: number) => {
      const tx = user.affiliateds
        .flatMap((a) => a.transactions)
        .find((t) => t.id === txId);

      if (tx) {
        pdf
          .fontSize(9)
          .font('Helvetica')
          .text(`${i + 1}. $${tx.amount.toFixed(2)} | ${tx.productName}`, {
            indent: 20,
          });
      }
    });

    pdf.moveDown(1);
  }

  /* ---------------- OBSERVATIONS ---------------- */

  private buildObservations(pdf: PDFKit.PDFDocument): void {
    pdf.fontSize(11).font('Helvetica-Bold').text('GENERAL OBSERVATIONS');

    pdf
      .fontSize(8)
      .font('Helvetica')
      .text(
        `This document reflects platform data at the time of generation.
Any modification invalidates the digital signature and integrity hashes.`,
        {
          indent: 20,
          width: 445,
          align: 'justify',
        },
      );

    pdf.moveDown(1);
  }

  /* ---------------- INVISIBLE WATERMARK ---------------- */

  private buildInvisibleWatermark(
    pdf: PDFKit.PDFDocument,
    contract: any,
    user: UserDocument,
  ): void {
    pdf.opacity(0.01);
    pdf
      .fontSize(50)
      .rotate(-45, { origin: [300, 400] })
      .text(
        `REF:${contract.contractId} | CONTRACT FOR:${user.affiliateCode}`,
        100,
        300,
        { align: 'center' },
      );
    pdf.rotate(45, { origin: [300, 400] });
    pdf.opacity(1);
  }

  /* ---------------- INTEGRITY ---------------- */

  private buildIntegritySection(
    pdf: PDFKit.PDFDocument,
    contract: any,
    user: UserDocument,
  ): void {
    const payload = {
      referenceId: contract.contractId,
      userId: user.userId,
      amount: contract.amount,
      status: contract.status,
      generatedAt: new Date().toISOString(),
    };

    const integrityHash = crypto
      .createHash('sha3-256')
      .update(JSON.stringify(payload))
      .digest('hex');

    pdf.moveTo(50, pdf.y).lineTo(545, pdf.y).stroke();
    pdf.moveDown(0.5);

    pdf
      .fontSize(10)
      .font('Helvetica-Bold')
      .text('DOCUMENT INTEGRITY RECORD', { align: 'center' });

    pdf.moveDown(0.3);

    pdf
      .fontSize(7)
      .font('Helvetica-Oblique')
      .text(`Integrity Hash (SHA3-256):\n${integrityHash}`, {
        align: 'center',
        width: 495,
      });
  }
}
